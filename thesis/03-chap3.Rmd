

```{r}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
library(here)
library(tidyverse)

source(here('analysis','base_functions','base_functions.R'))
library(latex2exp)

theme_c <- function(...){ 
   # font <- "Helvetica"   #assign font family up front
    # font <- "Arial"
    theme_bw() %+replace%    #replace elements we want to change
  
    theme(
      
      
      #text elements
      plot.title = element_text(             #title
                   size = 14,                #set font size
                   face = 'bold',            #bold typeface
                   hjust = .5,
                   vjust = 3),               
      
      plot.subtitle = element_text(          #subtitle
                   size = 12,
                   hjust = .5,
                   face = 'italic',
                   vjust = 3),               #font size
      
      axis.title = element_text(             #axis titles
                   size = 12),               #font size
      
      axis.text.x = element_text(              #axis text
                   size = 10),
      legend.text = element_text(size = 10),
      # t, r, b, l
      plot.margin = unit(c(1,.5,.5,.5), "cm"),
      legend.position = "right",
      strip.background=element_rect(fill = "#323232"),
      strip.text.x = element_text(size = 14, color = "white")
      ) %+replace%
      theme(...)
   
}


```



# Definition of Prior Distributions for Bias Parameters {#defpriors}


## Background on the Beta Distribution

The priors we are specifying here are for probabilities, with the exception of $\alpha$ and $\beta$, which represent ratios of probabilities. To define a prior for a parameter that takes on values in $[0,1]$, a particularly useful distribution is the beta distribution, which is only defined on the interval $[0,1]$. It is parameterized by two positive values $a, b$^[In R, $a$ = shape1 and $b$ = shape2.].

The beta  distribution is an extremely flexible distribution^[The beta distribution is also useful in Bayesian statistics, because it is the conjugate prior distribution for the binomial distribution and negative binomial distributions. That is, if we have a binomial likelihood with parameter $p$ and $p$ is distributed according to the beta distribution, the resulting posterior follows a beta distribution.]; by altering the parameters $a,b$, we can get an extensive array of shapes, as seen below. 


```{r, echo = FALSE, out.width = '90%'}

library(latex2exp)
library(tidyverse)
library(viridis)

alpha <- seq(.1, 6, by = .5)
  
beta <-  seq(.1, 6, by = .5)

x <- seq(0,1, length = 1000)


results <- map_df(alpha, function(alpha) {
  map_df(beta, ~{tibble(
    x = x,
    density = dbeta(x, 
                    shape1 = alpha, 
                    shape2 = .x),
    alpha = alpha,
    beta = .x)})})

results %>%
  mutate(params = paste0(alpha, 
                         beta,
                         sep = "_")) %>%
  ggplot(aes(x = x, 
             y = density, 
             color = params)) +
  geom_line( show.legend = FALSE) + 
  theme_bw() +
  scale_color_viridis(discrete=TRUE) +
  ylim(0, 7) +
  theme(axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        plot.title =element_text(face = "bold",
                                 hjust = .5)) +
  labs(title =  TeX("Beta Distributions for Different Values of $a$ and $b$"),
       y = TeX("$f(x|a, b)$"))



```


In defining a beta distribution to reflect knowledge about a parameter, we need to work backwards to find the parameters $a$ and $b$ that correspond to the desired mean and variance.  

There are multiple parameterizations of the beta distribution, but R uses that where we define the probability density function as

$$
f(x|a,b) = \dfrac{\Gamma(a + b)}{\Gamma(a) \Gamma(b)} x^{a - 1} (1-x)^{b - 1}.
$$
or equivalently as 
$$
f(x|a,\beta) = \dfrac{1}{B(a,b)} x^{a - 1} (1-x)^{b - 1},
$$
where the beta function $B(a, b) = \dfrac{\Gamma(a)\Gamma(b) }{\Gamma ( a + b)}$.


The expected value of the beta distribution is then $E(X) = \dfrac{a}{a + b}$ and the variance is given by $V(X) = \dfrac{a b}{(a + b)^2(a +b  + 1)}$; the derivation for both is given in the appendix. We can then solve for $a$ and $b$ to obtain $a = \Big(\frac{1-\mu}{\sigma^2} - \frac{1}{\mu}\Big) \mu^2$ and $b = \alpha\Big(\frac{1}{\mu} - 1\Big)$.  At this point, we can easily write a function in R that generates the parameters of the beta distribution with the desired mean and variance. 


## Background on the Gamma Distribution

The gamma distribution is another very flexible distribution. However, the support of the gamma distribution is $(0,\infty)$ rather than $[0,1]$. Because some of the bias parameters are not probabilities ($\alpha$ and $\beta$ are ratios of probabilities), we can instead use the gamma distribution to allow the random variable to take on values over 1. 

As with the beta distribution, a variety of shapes are possible with the gamma distribution.

```{r,  echo = FALSE, out.width = '90%'}

library(latex2exp)
library(tidyverse)
library(viridis)

shape <- seq(.1, 20, by = .8)
  
scale <-  seq(.1, 6, by = .8)

x <- seq(0,6, length = 1000)


results <- map_df(shape, function(shape_inp) {
  map_df(scale, function(scale_inp) {tibble(
    x = x,
    density = dgamma(x, 
                    shape = shape_inp, 
                    scale = scale_inp),
    shape = shape_inp,
    scale = scale_inp)})})

results %>%
  mutate(params = paste0(shape, 
                         scale,
                         sep = "_")) %>%
  ggplot(aes(x = x, 
             y = density, 
             color = params)) +
  geom_line( show.legend = FALSE) + 
  theme_bw() +
  scale_color_viridis(discrete=TRUE) +
  ylim(0, 7) +
  theme(axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        plot.title =element_text(face = "bold",
                                 hjust = .5)) +
  labs(title = 
         TeX("Gamma Distributions for Different Values of Shape and Scale"),
       y = TeX("$f(x|shape,scale)$")) +
  xlim(0,4)



```

Let $k=shape$ and $\theta=scale$. The parameterization of the gamma distribution that R uses is 

$$f(x|k,\theta) = \frac{1}{\Gamma(k) \;\theta^k}x^{k-1} e^{x/\theta}$$
where the mean $\mu =k\theta$ and the variance $\sigma^2 = k\theta^2$.

This allows us to obtain $\dfrac{\mu^2}{\sigma^2} = \dfrac{k^2 \theta^2}{k\theta^2} = k =shape$.

Then, substituting this result in for $k$, we have $$\sigma^2 = k \theta^2 = \dfrac{\mu^2}{\sigma^2} \theta^2$$
$$\frac{\sigma^4}{\mu^2}=\theta^2$$

$$\frac{\sigma^2}{\mu}=\theta = scale.$$
This allows us to calculate the shape and scale parameters of a gamma distribution with the desired mean and variance. 

```{r}

get_gamma_params <- function(mu, sd) {
    var = (mu/sd)^2
    shape = (mu/sd)^2
    scale = sd^2/mu
    return(params = list(shape = shape, scale = scale))
}

```

```{r,eval=FALSE,include=FALSE}
####################
# TEST
####################


mean <- 2
std <- 1.5

params <- get_gamma_params(mu = mean, sd = std)


samp <- rgamma(1e4, 
       shape = params$shape, 
       scale = params$scale)

mean(samp)
sd(samp)

```


## Definition of Prior Distributions for Incomplete Testing Correction



### Defining $P(S_1|\text{untested})$

We recall that $S_1$ denotes the event that an individual has moderate to severe symptoms, so
 $P(S_1|Untested)$ is the probability of having moderate to severe symptoms among those who were not tested. We note that this would include people that have moderate to severe COVID-like symptoms that do indeed have COVID-19 as well as people that do not have COVID-19 and have some other respiratory illness.
 
Wu et al. (2020) defined this distribution such that $P(S_1|\text{untested}) \sim TBeta(\alpha = 1.18, \beta = 45.97)$, bounded between 0 and 15%, as we see below. When we define the distribution of $P(S_1|\text{untested})$, we release the truncation. Furthermore, we actually remove the truncation on all prior distributions considered. This choice was based on the fact that we have a lack of data to support particular bounds for a truncated distribution, and such assumptions can lead to difficulties in the Bayesian melding component of the probabilistic bias analysis. 


```{r, fig.width=7, fig.height = 3, echo=FALSE}

alpha <- 1.18
beta <- 45.97

get_beta_params <- function(mu, sd) {
  var = sd^2
  alpha <- ((1 - mu) / var - 1 / mu) * mu ^ 2
  beta <- alpha * (1 / mu - 1)
  return(params = list(alpha = alpha, beta = beta))
}

# truncated support between a=0, b=0.15
trunc_beta_s1_untested <- function(x) {
  truncdist::dtrunc(x,spec = "beta",a = 0,b = 0.15,
                    shape1 = get_beta_params(mu = 0.025, sd = (0.15)^2)$a,
                    shape2 = get_beta_params(mu = 0.025, sd = (0.15)^2)$b)
} 

wubeta <- tibble(x = seq(0, 1, by = 10^(-5)),
       y = trunc_beta_s1_untested(x)) %>%
  mutate(source ="Wu et al.'s\nDefinition")


prior_params <- list(
    alpha_mean = .95,
    alpha_sd = 0.08,
    alpha_bounds = NA,
   # alpha_bounds = c(.8,1),
    beta_mean = .15,
    beta_sd =.09,
    beta_bounds = NA,
  #  beta_bounds = c(0.002, 0.4),
    s_untested_mean = .03,
    s_untested_sd = .0225,
  #  s_untested_bounds = c(0.0018, Inf),
    s_untested_bounds = NA,
    p_s0_pos_mean = .4,
    p_s0_pos_sd = .1225,
   p_s0_pos_bounds = NA,
  #  p_s0_pos_bounds = c(.25, .7),
    pre_nsamp = 1e5,
    post_nsamp = 1e4)

tibble(x = seq(0, 1, length = 10^(5)),
       y = with(prior_params, beta_density(x,
                                            mean = s_untested_mean,
                                            sd = s_untested_sd,
                                            bounds = s_untested_bounds))) %>%
  mutate(source =  "Definition Here") %>%
  bind_rows(wubeta) %>%
   ggplot(aes(x=x, y = y, group=source)) +
  geom_line(alpha = .8) + 
  geom_ribbon(aes(x=x,ymin=0,ymax=y, fill=source),
              alpha=.6) +
  theme_c(legend.text=element_text(size = 10)) +
  viridis::scale_fill_viridis(discrete=TRUE,
                             option = "rocket", begin=.3,end=.8) +
  labs(x = "Value",
       y = "Probability Density", 
       title = latex2exp::TeX("Comparing Definitions of $P(S_1|untested)$"),
       fill ='') 

```


However, to implement this approach over a more extended time interval, we need to allow this parameter to vary by time. Due to state-specific differences in symptom prevalence, it also makes more sense to allow this parameter to vary by state.
 
 To do this, we can use the COVID-like illness indicator from the COVID-19 Trends and Impact Survey  [@salomon2021]. The COVID-19 Trends and Impact Survey (CTIS) is a large scale internet-based survey that invites a sample of Facebook users to respond to questions on several topics of public health interest, including testing and symptom status. The survey effort selects participants using stratified random sampling by state, and responses are aggregated and made publicly available.
 
Below, we see that the distribution of the proportion of the population with COVID-like illness over all of 2021 is in a similar range as the distribution defined for $P(S_1|untested)$, with the bulk of the distribution between 0 and 15%, although the COVID-19-like-illness has more density toward zero.


```{r, echo = FALSE, out.width="80%",eval=FALSE}

# https://cmu-delphi.github.io/delphi-epidata/api/covidcast.html
# influenza-like illness

fb_symptoms <- httr::GET('https://api.covidcast.cmu.edu/epidata/covidcast/?data_source=fb-survey&signal=smoothed_wcli&time_type=day&geo_type=state&time_values=20210101-20220226&geo_value=*')


fb_symptoms <-jsonlite::fromJSON(
     httr::content(fb_symptoms,
                   as = "text", 
                   encoding = "UTF-8"),
     simplifyVector = TRUE,
     flatten = TRUE)


fb_symptoms <- readRDS(here("data/state_level/screeningpos_all_states.RDS"))

fb_symptoms <- fb_symptoms %>% 
  select(signal, date, value, state = geo_value) %>% 
  pivot_wider(names_from = signal,
              values_from = c(value)) %>%
  mutate(beta_est = smoothed_wscreening_tested_positive_14d/smoothed_wtested_positive_14d)


fb_symptoms %>%
  mutate(p_s_untested = with(prior_params, 
                             sample_beta_density(n =  nrow(fb_symptoms), 
                                                 mean=s_untested_mean, 
                                                 sd=s_untested_sd))) %>%
           select(p_s_untested, smoothed_wcli) %>%
           pivot_longer(cols=everything()) %>%
  mutate(name = ifelse(name == "p_s_untested", 
                       "Defined Distribution of $P(S_1|untested)$",
                       "COVID-19-like Illness")) %>%
   ggplot(aes(x=value, fill = name)) +
  geom_density(alpha = .8) +
  viridis::scale_fill_viridis(option ="mako", discrete=TRUE, end =.8, begin=.1, 
                              labels=latex2exp::TeX(c("Defined Distribution of $P(S_1|untested)$",  "COVID-19-like Illness")),
                              name='') +
  theme_c(plot.title=element_text(size=12, hjust = .5, margin=margin(0,0,3,0))) +
  labs(title =latex2exp::TeX( "Comparing Defined Distribution of $P(S_1|untested)$ to Distribution of COVID-19-like Illness"))

ggsave(here('thesis/figure/emp_p_s_untested.pdf'), width = 9.2, height =5)

# 
# fb_symptoms <- fb_symptoms$epidata %>%
#   mutate(desc = case_when(
#     signal == "smoothed_wili" ~ "Estimated percentage of people\nwith influenza-like illness",
#     signal == "smoothed_wcli" ~ "Estimated percentage of people\nwith COVID-like illness"),
#     date = lubridate::ymd(time_value),
#     state = substr(geo_value, 1, 2)) 
# 
# m <- fb_symptoms  %>%
#   group_by(signal) %>%
#   mutate(m = mean(value, na.rm = TRUE)) %>%
#   pull(m) %>% unique()
# 
# fb_symptoms  %>%
#   mutate(value = value/100) %>%
#   group_by(signal) %>%
#   mutate(mean_pct = mean(value, na.rm = TRUE)) %>%
#   ungroup() %>%
#   ggplot(aes(x = value)) +
#   geom_histogram() +
#   geom_vline(aes(xintercept = mean_pct), color = "darkred") + 
#   # geom_text(aes(x=mean_pct + 2, 
#   #               label = paste0("Mean =", round(mean_pct,2)),
#   #               y = 25000), 
#   #           colour="darkred") +
#  # facet_wrap(~desc) +
#   theme_bw() +
#   theme(strip.text =element_text(size = 14, face = "bold"),
#         plot.title = element_text(face = "bold", hjust = .5, size = 18),
#         plot.subtitle = element_text(face = "italic", hjust = .5, size = 16)) +
#   labs(x = "Estimated Proportion of People",
#        title = "Distribution of Proportion of People with COVID-like Illness",
#                               subtitle = paste0("Mean = ", round(m,2))) +
#   scale_x_continuous(n.breaks = 8)
# 
# ggsave("./figure/emp_distribution_p_s_untested.png", dpi = 400)
# 
# # percentage over time, by state 
# fb_symptoms  %>%
#   mutate(value = value/100) %>%
#   ggplot(aes(x = date, y = value, color = state)) +
#   geom_line(show.legend=FALSE, size = .2) +
#   theme_bw() +
#   theme(strip.text =element_text(size = 14, face = "bold"),
#         plot.title = element_text(face = "bold", hjust = .5, size = 18),
#         plot.subtitle = element_text(face = "italic", hjust = .5, size = 16),
#         axis.title = element_text(size = 14)) +
#   labs(title = "Estimated Percentages of People with\nCOVID-like Illness by State",
#        y = "State Mean") +
#   viridis::scale_color_viridis(discrete=TRUE, option = "inferno")
#   
# ggsave("./figure/cli_by_state.png", dpi = 400)


```

```{r, echo = FALSE,out.width = "80%"}
knitr::include_graphics("figure/emp_p_s_untested.pdf")
```


### Defining $\alpha$


We define $\alpha$ as the ratio  $\frac{P(\text{test}_+|S_1, \text{untested})}{P(test+|\text{tested})}$, applied to allow
$P(\text{test}_+|S_1, \text{untested})$ to vary by state. $P(\text{test}_+|\text{tested})$ is the state-level empirical estimate, but we do not calculate $\alpha$ itself using the state-level empirical estimate. Instead, we calculate $P(\text{test}_+|S_1, \text{untested})$ as $P(\text{test}_+|S_1, \text{untested}) =\alpha P(\text{test}_+|\text{tested})$. We can think about $\alpha$ as the adjustment to the test positivity rate as we estimate the probability of testing positive among symptomatic *untested* individuals. We assume this ratio is close to 1, that is, that the probability of testing positive among symptomatic untested individuals would be near 90% of the probability of testing positive among tested individuals (not all of whom would be symptomatic).

With the the expansion of testing resources in 2021, it is plausible that $P(\text{test}_+|\text{untested},S_1)$ could exceed $P(\text{test}_+|\text{tested})$, so we use a gamma distribution to allow $\alpha$ to take on values greater than 1.


```{r, out.width = '80%',echo=FALSE}

tibble(x = seq(0, 1.3, length =1000), 
       y =  with(prior_params, {
  gamma_density(x, mean=alpha_mean,
                sd=alpha_sd)})) %>%
  ggplot(aes(x= x,ymin =0, ymax=y)) +
  geom_ribbon(alpha = .8) +
  labs(x = "Value", y = "Probability Density", 
       title = latex2exp::TeX("Distribution of $\\alpha$")) +
  theme_c()


```


### Defining $\beta$


 Similar to the way we defined $\alpha$, we define $\beta$ as the ratio of $\dfrac{P(\text{test}_+ |S_0, \text{untested})}{P(\text{test}_+|\text{tested})}$, applied to allow $P(\text{test}_+ |S_0, \text{untested})$ to vary by state. We use $\beta$ to calculate $P(test+|S_1, \text{untested})$ by the expression $P(\text{test}_+|S_0, \text{untested}) =\beta P(\text{test}_+|\text{tested})$. We can think about $\beta$ as the adjustment to the test positivity rate as we estimate the probability of testing positive among aymptomatic untested individuals (in contrast to $\alpha$, which is symptomatic untested individuals). We assume the values of $\beta$ are substantially lower than $\alpha$, reflecting that we expect a much smaller proportion of asymptomatic untested individuals to test positive than symptomatic individuals.
 
 
 


```{r, out.width = '80%', fig.height = 3, echo=FALSE}



tibble(x = seq(0, 1.3, length =1000), 
       y =  with(prior_params, {
  beta_density(x, mean=beta_mean,
                sd=beta_sd)})) %>%
  ggplot(aes(x= x,ymin =0, ymax=y)) +
  geom_ribbon(alpha = .8) +
  labs(x = "Value", y = "Probability Density", 
       title = latex2exp::TeX("Distribution of $\\beta$")) +
  theme_c()


```


Because we define $\beta$ as the ratio of $\frac{P(\text{test}_+ |S_0, \text{untested})}{P(\text{test}_+|\text{tested})}$, we can estimate $\beta$ empirically by taking the screening test positivity rate as an estimate of $P(test + |S_0, untested)$ and then dividing by the overall test positivity rate $P(\text{test}_+|\text{tested})$. State-level estimates for screening test positivity and overall test positivity are available through the COVID-19 Trends and Impact Survey, enabling us to obtain a time and state-specific estimate of $\beta$.

### Defining $P(S_0|\text{test}_+,\text{untested})$

$P(S_0|\text{test}_+,\text{tested})$ is the probability of not having symptoms among those who test positive, that is, the asymptomatic rate of COVID-19. Although we can never obtain a true estimate of $P(S_0|\text{test}_+,\text{untested})$ given it is by nature unobserved, we can look to studies that estimate $P(S_0|\text{test}_+,\text{tested})$.

One large meta-analysis found $P(S_0|test+)$ to be 40.50% (95% CI: 33.50%-47.50%), although it did not restrict to screening studies [@ma2021a]. Another meta-analysis, when restricting to screening studies,  found $P(S_0|test+)$ to be 47.3% (95% CI: 34.0% -61.0%) [@sah2021a].

```{r, out.width = '80%', fig.height = 3}


tibble(x = seq(0, 1.3, length =1000), 
       y =  with(prior_params, {
  beta_density(x, mean=p_s0_pos_mean,
                sd=p_s0_pos_sd)})) %>%
  ggplot(aes(x= x,ymin =0, ymax=y)) +
  geom_ribbon(alpha = .8) +
  labs(x = "Value", y = "Probability Density", 
       title = latex2exp::TeX("Distribution of $P(S_0|test+, untested)$")) +
  theme_c()




```


## Definition of Priors for Test Inaccuracy Correction

### Defining Test Sensitivity ($S_e$)

We define the the test sensitivity and test sensitivity to follow the definitions in @wu2020. 
$S_e$ is defined such that $S_e \sim TBeta(\alpha = 4.20, \beta = 	1.05)$, bounded between 0.65 and 1 and with mean $\dfrac{\alpha}{\alpha + \beta} = 0.80$.




```{r, echo = FALSE, out.width = "80%"}

p_se <- function(x){
  truncdist::dtrunc(x = x,spec = "beta",a = 0.65,b = 1,
                    shape1 = get_beta_params(mu = 0.8, sd = (0.4)^2)$alpha,
                    shape2 = get_beta_params(mu = 0.8, sd = (0.4)^2)$beta)
}

tibble(x = seq(0, 1, by = 10^(-4)),
       y = p_se(x)) %>%
  ggplot(aes(x=x, ymin=0,ymax = y)) +
  geom_ribbon(fill="black", alpha = .9) +
  theme_c() +
  labs(x = "Value", y = "Probability Density", 
       title = TeX("$S_e$")) 



```

**Data available for informing this prior distribution:** 

In a population-based retrospective study including both inpatients and outpatients, the clinical sensitivity was estimated to be 89.9% (95% CI 88.2 – 92.1%) by considering repeat-tested patients who initially tested negative but later tested positive [@kortela2021a]. However, as Kortela *et al.* discussed, this approach is likely an overestimate of the true clinical sensitivity, because individuals will only be tested twice if there is high clinical suspicion that they do have COVID-19. To account for this, they produced an estimate of sensitivity including cases with high clinical suspicion in the denominator, which resulted in an estimate closer to 50%, yet this is likely an underestimate due to the fact that even those with a classical COVID-19 symptom presentation may not have COVID-19. They concluded that due to these biases, the true value most likely falls between the overestimate near 90% and the underestimate near 50%.

Another analysis of repeat-tested patients using data from a large sample of patients tested at the provincial Public Health Laboratory in Canada estimated the clinical sensitivity to be 90.7% (95% CI 82.6–98.9%) [@kanji2021]. Green *et al.* found that the clinical sensitivity ranged from 58% to 96%: the estimate of 96% was dependent on the assumption that negative results, repeated or not, were true negatives, while the estimate of 58% assumed the rate of false negatives among the repeat-tested population would be the same as in the repeat-tested patients [@green2020]. In a meta-analysis of 51 studies, Mustafa *et al.* found a pooled estimate of the clinical sensitivity as 0.96 (95% CI 93% - 98%) [@mustafahellou2021]. 

Because PCR tests are designed to target a highly conserved region of the viral genome, their sensitivity was expected to be relatively robust to the circulation of different variants of SARS-CoV-2. However, analytical sensitivity has shown some differences by genetic variants [@chen2022]. Viral shedding dynamics also have differed by genetic variant, but the variants dominant throughout most of the time period considered here, Delta and Omicron, have similar viral loads [@fall2022; @singanayagam2022]. 


```{r, echo = FALSE, eval = FALSE}

library(lubridate)
library(tidyverse)

# source: https://dev.socrata.com/foundry/data.cdc.gov/jr58-6ysp
# https://www.cdc.gov/media/releases/2021/s1126-B11-529-omicron.html

var <- httr::GET(
   URLencode(paste0("https://data.cdc.gov/resource/jr58-6ysp.json?",
   "usa_or_hhsregion=USA&time_interval=weekly")))

#var <- httr::GET("https://data.cdc.gov/resource/jr58-6ysp.json?week_ending=2022-07-02T00:00:00.000")
var <-jsonlite::fromJSON(
      httr::content(var,
                    as = "text", 
                    encoding = "UTF-8")) %>%
  as_tibble()

var <- var %>%
  mutate(date = substr(week_ending,1,10),
         date =strptime(date, "%Y-%m-%d"),
         creation_date =strptime(creation_date, "%Y-%m-%d")) %>%
  filter(modeltype == "weighted" & date <= ymd("2022-02-25")) %>%
  mutate(across(c(share, share_hi, share_lo), as.numeric))

# B.1.1.529 omicron/ B.1.1 also omicron
# B.1.617.2 delta 
# only one creation date (most recent)
var <- var %>%
  group_by(date) %>%
  slice_max(order_by = creation_date, n = 1) %>%
  mutate(date = ymd(date)) %>%
  select(-contains("creation"))

# http://vrl.cs.brown.edu/color

pal <- c("#68affc", "#406087", "#8de6c0", "#096013", "#9de866",
         "#31a62e", "#11a0aa", "#4443b4", "#c052e4", "#722e57",
         "#e3a6d5", "#e01e82", "#8e80fb", "#5010c8", "#cad7d4",
         "#829951")



var %>% mutate(
  variant_name = case_when(
  variant %in% c("B.1.1.529", 
                  "B.1.1", 
                  "BA.1.1", 
                  "BA.2",
                  "BA.3", 
                  "BA.4",
                  "BA.5") ~ "Omicron",
  variant %in% "B.1.617.2" ~ "Delta",
  TRUE ~ "Other")) %>%
  ggplot(aes(x =date, 
             y = share, 
             fill = variant_name)) +
  geom_bar(stat="identity",
           alpha = .8) +
  scale_fill_viridis(discrete=TRUE)+
  #scale_fill_manual(values = pal ) +
  theme_bw() + 
  theme(legend.position = "right",
          legend.title = element_text(face = "bold", size = 16),
        plot.title = element_text(face = "bold", hjust = .5, size = 18))  +
  scale_x_date(date_breaks = "2 months", date_labels = "%b %Y") +
  labs(title = "Variant Proportions over Time",
       fill = "Variant")

ggsave("./figure/variant_plot.jpg", dpi = 600)


```

```{r, out.width = "80%", fig.height=3, fig.cap = "Variant proportions in the United States from genomic surveillance data collected by the CDC. Data is not available for time periods earlier than May 8, 2021.", echo = FALSE}

knitr::include_graphics("./figure/variant_plot.jpg")

```

Ultimately, although it is plausible that test sensitivity may vary by time due to differences in viral shedding dynamics over time as well as differences due to the mutations present in circulating variants, there is a lack of data to inform exactly how the sensitivity may vary over time. As a result, we assume the test sensitivity is independent and identically distributed across time periods.
 

## Defining Test Specificity ($S_p$)

The test specificity $P(\text{test negative}| \text{negative})$ is defined as $P(\text{test negative}| \text{negative}) \sim TBeta(a = 4998.50, \beta = 	0.25)$, bounded between 0.9998 and 1 and with mean $\dfrac{a}{a + b} = 0.99995$. The high certainty for this parameter is based on the CDC 2019-nCoV Real-Time RT-PCR Diagnostic Panel.



```{r,echo=FALSE, out.width = "80%"}

p_sp <- function(x){
  truncdist::rtrunc(n = x,spec = "beta",a = 0.9998	,b = 1,
                    shape1 = get_beta_params(mu = 0.99995, sd = (0.01)^2)$alpha,
                    shape2 = get_beta_params(mu = 0.99995, sd = (0.01)^2)$beta)
}

tibble(x = p_sp(10000)) %>%
  ggplot(aes(x=x)) +
  geom_density(fill = "black", alpha = .8) +
  xlim(0,1) +
  theme_c(axis.text.y = element_blank(),
          axis.ticks.y = element_blank()) +
  labs(x = "Value", y = "Probability Density", 
       title = TeX("$S_p = P(test - | -)$")) 



```


## Exploration of the Implications of Changes in the Bias Parameters

To explore the implications of changes in the bias parameter distributions both on the melding and the final corrected estimates, we developed the Shiny app hosted [here](https://q-w-a.shinyapps.io/bayesian_melding_priors/).^[Code is available at the repository [here](https://github.com/q-w-a/probabilistic_bias_correction)]. 


## Correction for Incomplete Testing 

We denote $N^*$ to be positive tests (not infections).

As discussed previously, once we have sampled values from the constrained distributions of $P(S_1|untested)$, $\alpha$, $\beta$, we estimate the test positivity among the symptomatic untested population as $P(+|S_1,untested) = \alpha \; P(test +|tested)$, and we estimate the test positivity among the asymptomatic untested population as $P(+|S_0,untested) = \beta \; P(test +|tested)$. Then, we compute the positives among the symptomatic and mild/asymptomatic parts of the population respectively as 

$$N^*_{\text{untested},S_1} = N_{\text{untested}} \; P(S_1|\text{untested}) \cdot P(\text{test}_+ | S_1,\text{untested}) \;\;\;\text{ and }$$
$$N^*_{\text{untested},S_0} = N_{\text{untested}}(1-P(S_1|\text{untested}))P(test + | S_0,\text{untested}).$$
Then, we take the total positives among the untested population as 

$$N^*_{\text{untested}} = N^*_{\text{untested},S_1} + N^*_{\text{untested},S_0}$$
and finally we add the number of observed positives, $N^*_{tested}$ to obtain the estimate for the positives among the total population, as 

$$N^* = N^*_{\text{tested}} +N^*_{\text{untested}}.$$



```{r,echo=FALSE,include=FALSE,eval=FALSE}
### Acquiring $N^+_{{untested}, S_1}$

$N^+_{{untested}, S_1}$ = the number of **symptomatic untested people** who have COVID-19.

We know
\[ N^+_{untested} = (N_{\text{untested}})  \cdot P(+,S_1 | \text{untested}).\]

Now, we need to show \[ P(+,S_1 | {untested}) = P(S_1|untested) \cdot P(test \; + | S_1, untested).\]


We can see this by writing 

\[ P(+,S_1 | {untested})  =  \dfrac{P(+,S_1 , {untested}) }{P(untested)}\]

and since $P(+|S_1, untested ) = \dfrac{P(untested, +, S_1)}{P(S_1, untested)}$ we have

\[ P(+,S_1 | {untested})  =  \dfrac{P(+|S_1, untested )P(S_1, untested) }{P(untested)}.\]

Because $\dfrac{P(S_1, untested) }{P(untested)} = P(S_1| untested)$
we can substitute into this expression to give us 
\[ P(+,S_1 | {untested})  =  P(+|S_1, untested )P(S_1|untested) .\]
Thus, $N^+_{{untested}, S_1}$ can be acquired by taking

\[
N^+_{{untested}, S_1}= P(+|S_1, untested )\cdot P(S_1|untested) \cdot N_{untested}.
\]

### Acquiring $N^+_{{untested}, S_0}$

$N^+_{{untested}, S_0}$ = the number of **asymptomatic untested people** who have COVID-19.

Using similar logic, we can find $N^+_{{untested}, S_0}$. That is, we can take
\[
N^+_{{untested}, S_0}= P(+|S_0, untested )\cdot P(S_0|untested) \cdot N_{untested}
\]
where $P(S_0|untested)  = (1- P(S_1|untested))$.

  
```



## Correction for Diagnostic Test Inaccuracy {#correct-test-inaccuracy}

At this point, we have corrected for the incompleteness of testing. That is, we have an estimate of who would have tested positive if we tested the entire population. However, we also need to correct for imperfect test accuracy. 

Test accuracy is broken up into two components, specificity and sensitivity.

We define test sensitivity and specificity as follows:
* $S_e$ = test sensitivity = the probability an individual tests positive if they have COVID-19 (probability of a true positive), that is, $P(\text{test}_+ | +)$. 
* $S_p$ = test specificity = probability an individual tests negative if they do not have COVID-19 (probability of a true negative), that is, $P(\text{test}_- |-)$.

Then, given that we have the number $N^+$ who tested positive (or, in the context of this work, would have tested positive), the specificity $S_p$, the sensitivity $S_e$, and the total population size $N$, we can calculate the true positives with the formula
$$\text{Number Truly Positive} = \dfrac{N^* - (1-S_p) \times N}{S_e+S_p-1}$$
from Modern Epidemiology [@rothman2008].

### Derivation of Formula for Correction for Diagnostic Test Inaccuracy

We define test sensitivity and specificity as follows:
* $S_e$ = test sensitivity = the probability an individual tests positive if they have COVID-19 (probability of a true positive), that is, $P(test + | +)$. 
* $S_p$ = test specificity = probability an individual tests negative if they do not have COVID-19 (probability of a true negative), that is, $P(test - |-)$.

As defined previously, $S_e \sim TBeta(0.65, 1)$ and $S_p \sim TBeta(0.998, 1)$.

To correct case counts for diagnostic test inaccuracy, we use the formula 
$$\text{Number Truly Positive} = \dfrac{N^*- (1-S_p) \times N}{S_e+S_p-1}$$
as defined in Rothman et al. (2008).

To obtain this formula, we let:

* $N$ denote the total population size
* $N^*$ denote the number *classified* as positive
* $N^-$ denote the number *classified* as negative
* $T^+$ denote the number that is *truly* positive
* $T^-$ denote the number that is *truly* positive


We also recall that 
\[ \text{Sensitivity} = S_e = P(test + | +) \]
\[ \text{Specificity} = S_p = P(test - | - ) \] 


The quantity we want to estimate is the number of truly positive individuals when accounting for imperfect test accuracy, that is, $T^+$.

The number classified as positive, $N^+$ can be written as 

\[ N^* = P(test + | +) T^+ + P(test + | -) T^-\]

where $P(test + | +) T^+$ is the number of true positives and $P(test + | -) N^-$ is the number of false positives. By the definitions of  sensitivity $S_e$ and specificity $S_p$ we can write this more clearly as 
\[ N^* =S_e T^+ + (1-S_p) T^-.\]


Meanwhile, the number classified as negative, $N^-$ can be written as 

\[ N^- = P(test - | -) T^- + P(test - | +) T^+\]

where $P(test - | -) T^-$ is the number of true negatives and $P(test - | +) T^+$ is the number of false negatives. Substituting in $S_e$ and $S_p$ we can express this as 

\[ N^- = S_p T^- + (1-S_e) T^+.\]

At this point, we can solve the expression $N^- = S_p T^- + (1-S_e) T^+$ for the number of people classified as positive for the number truly negative, $T^-$. This yields

\[\dfrac{( N^- - (1-S_e) T^+) }{S_p}=  T^- .\]

Now, we can substitute this result into our expression for $N^+ =S_e T^+ + (1-S_p) T^-$ and solve for the desired value, the number of truly positive individuals, $T^+$. This gives us

\[
 N^* =S_e T^+ + (1-S_p)  \left( \dfrac{( N^- - (1-S_e) T^+) }{S_p} \right)
\]

\[
 S_p \; N^* =S_pS_e T^+ + (1-S_p)  \left( {( N^- - (1-S_e) T^+) } \right)
\]

\[
 S_p \; N^* =S_pS_e T^+ + (1-S_p)  ( N^-)  - (1-S_p)(1-S_e) T^+
\]

\[
 S_p \; N^* -   (1-S_p)  ( N^-) =S_pS_e T^+  - (1-S_p)(1-S_e) T^+
\] 

\[
 S_p N^* -   (1-S_p)  ( N^-) = (S_pS_e  - (1-S_p)(1-S_e)) T^+
\] 

\[
 S_p \; N^* -   (1-S_p)  ( N^-) = (S_p + S_e - 1) T^+
\] 

\[
 T^+ = \dfrac{ S_p \; N^* -   (1-S_p)  ( N^-)}{(S_p + S_e - 1)} 
\] 

At this point we can simplify the numerator as follows by using the fact $N =N^* + N^-$. This gives us 

\begin{align*} =S_p \;N^* -   (1-S_p)  N^-\\
=  S_p   N^* + S_p  N^- - N^-\\
=  S_p(N^* +  N^-) - N^- \\
=  S_pN - (N-N^*) \\
=  S_pN - (N-N^*) \\
=  (S_p-1)N + N^* \\
=  N^* - (1-S_p)N\\
\end{align*}

so we have 
\[
 T^+ = \dfrac{ N^*- (1-S_p)N}{(S_p + S_e - 1)}.
\] 

  

